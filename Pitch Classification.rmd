The purpose of this markdown script is to see if we can determine an objective number of pitch types thrown by baseball pitchers. To do this, we'll use in-game Trackman data, along with a few different analysis techniques.

Analyses:
1. Gaussian Mixture Models (GMM)
__GMM assumes data is generated from a mixture of several Gaussian distributions, allowing for soft clustering (probabilistic assignment) and elliptical cluster shapes. This is particularly good when pitch types overlap (e.g., cutters vs. fastballs).__

  Use case: Model uncertainty in pitch classifications; helpful when pitches transition fluidly between types.
  
2. HDBSCAN (Hierarchical Density-Based Spatial Clustering of Applications with Noise)
__This is a variant of DBSCAN (Density-Based Spatial Clustering) that does not require k, and handles varying densities well.__

Very good for identifying:
- Dense pitch types
- Sparse or rare types
- Noise/outliers

3. Autoencoder + Clustering (this is more advanced than I am currently comfortable with)
__This approach trains an autoencoder (or variational autoencoder) to learn a compressed representation of the ball metrics. Then, it applies clustering (e.g., k-means or GMM) on the latent space.__

Benefits:
- Non-linear dimensionality reduction for better separation of similar pitch types.
- Works well with noisy or high-dimensional data.
- Variants: Deep Embedded Clustering (DEC), Variational Deep Embedding (VaDE)


**Having run the GMM without break characteristics, I think it may be best to include these to help split pitches better. Currently, RHP and LHP are throwing 9 distinct pitch types each**


If the packages below need to be installed, removed the "eval=FALSE" from the curly brackets
```{r install packages if required, eval=FALSE}
install.packages(c("mclust", "umap", "plotly", "scales", "tidyverse", "dbscan"))
```

First, let's load the packages we need to perform this analysis
```{r load packages, message=FALSE}
library(mclust)
library(umap)
library(plotly)
library(scales)
library(tidyverse)
library(dbscan)
```

Now let's read in the data
```{r load data}
d <- read.csv("Data/master_TrackMan_2025.csv")
```

Having seen no difference in the number of identified pitch clusters when running this analysis with both release characteristics, and break profiles separately, the decision was made to use break profiles exclusively. This was largely down to the fact that this approach allowed for a more interpretable visualisation of each model (something that release parameters struggled with).
```{r rename columns of interest}
names(d)[names(d) == "RelSpeed"] <- "velocity"
names(d)[names(d) == "VertRelAngle"] <- "vertical_release_angle"
names(d)[names(d) == "HorzRelAngle"] <- "horizontal_release_angle"
names(d)[names(d) == "SpinRate"] <- "spin_rate"
names(d)[names(d) == "SpinAxis"] <- "spin_axis"
names(d)[names(d) == "RelHeight"] <- "release_height"
names(d)[names(d) == "RelSide"] <- "release_side"
names(d)[names(d) == "Extension"] <- "extension"
names(d)[names(d) == "InducedVertBreak"] <- "ivb"
names(d)[names(d) == "VertBreak"] <- "vb"
names(d)[names(d) == "HorzBreak"] <- "hb"
```

Some of the columns we will be using are currently not in metric. We, therefore, need to convert these before proceeding.
```{r metric conversion}
d$velocity <- d$velocity * 0.44704
d$release_height <- d$release_height * 0.3048
d$release_side <- d$release_side * 0.3048
d$extension <- d$extension * 0.3048
d$ivb <- d$ivb * 0.0254
d$vb <- d$vb * 0.0254
d$hb <- d$hb * 0.0254
```

To better help the analysis of this data, we are going to separate out right- and left-handers. This is owing to **"horizontal_release_angle"**, **"spin_axis"**, and **"release_side"** being different for each group (the values are essentially flipped for left-handed throwers). We're also going to remove any rows where missing values are.
```{r split data}
d_right <- d %>%
  filter(PitcherThrows == "Right") %>%
  select(20:21, 29:33, 35:40)

d_right <- d_right[complete.cases(d_right), ] # remove any rows where metrics might be missing

d_left <-d %>%
  filter(PitcherThrows == "Left") %>%
  select(20:21, 29:33, 35:40)

d_left <- d_left[complete.cases(d_left), ]   # remove any rows where metrics might be missing
```

Identify the features (ball metrics) that we're interested in.
```{r features - release parameters}
features <- c("velocity", 
              "vertical_release_angle", 
              "horizontal_release_angle", 
              "spin_rate", 
              "spin_axis", 
              "release_height", 
              "release_side", 
              "extension",
              "vb",
              "ivb",
              "hb")
```

```{r features - break profile}
features2 <- c("vb",
               "ivb",
               "hb")
```


```{r right handed pitchers}
rX <- scale(d_right[, features2]) # scale features

# fit Gaussian Mixture Model (GMM)
gmm_modelr <- Mclust(rX)
best_kr <- gmm_modelr$G
d_right$cluster <- as.factor(gmm_modelr$classification)
cat("Optimal number of clusters for RHP based on break profile:", best_kr, "\n")

# UMAP for dimensionality reduction
# Uniform Manifold Approximation and Projection
set.seed(0312)
r_umap_result <- umap(rX)

# create a UMAP dataframe with pitch type labels
r_umap_df <- data.frame(
  UMAP1 = r_umap_result$layout[, 1],
  UMAP2 = r_umap_result$layout[, 2],
  cluster = d_right$cluster,
  inducedVB = d_right$ivb,
  VB = d_right$vb,
  HB = d_right$hb,
  # velocity = d_right$velocity,
  # spin_rate = d_right$spin_rate,
  # spin_axis = d_right$spin_axis,
  TaggedPitchType = d_right$TaggedPitchType,
  AutoPitchType = d_right$AutoPitchType
)

# rhp interactive plot
plot_rhp <- plot_ly(
  r_umap_df,
  x = ~UMAP1,
  y = ~UMAP2,
  type = 'scatter',
  mode = 'markers',
  color = ~cluster,
  colors = hue_pal()(best_kr),
  text = ~paste(
    "Cluster:", cluster,
    "<br>Tagged:", TaggedPitchType,
    "<br>Auto:", AutoPitchType,
    "<br>Induced VB (deg):", round(inducedVB, 2),
    "<br>VB (deg):", round(VB, 2),
    "<br>HB (deg):", round(HB, 2)
    # "<br>Velocity (m.s):", round(velocity, 1),
    # "<br>Spin Rate (deg/s):", round(spin_rate, 0),
    # "<br>Spin Axis (deg):", round(spin_axis, 0)
  ),
  marker = list(size = 8, opacity = 0.8)
) %>%
  layout(
    title = "RHP GMM Clustering (UMAP Projection)",
    xaxis = list(title = "UMAP1"),
    yaxis = list(title = "UMAP2"),
    legend = list(title = list(text = "Cluster"))
  )
```


```{r left handed pitchers}
lX <- scale(d_left[, features2])  # scale features

# fit Gaussian Mixture Model (GMM)
gmm_modell <- Mclust(lX)
best_kl <- gmm_modell$G
d_left$cluster <- as.factor(gmm_modell$classification)
cat("Optimal number of clusters for LHP based on break profile:", best_kl, "\n")

# UMAP for dimensionality reduction
# Uniform Manifold Approximation and Projection
set.seed(0312)
l_umap_result <- umap(lX)

# create a UMAP dataframe with pitch type labels
l_umap_df <- data.frame(
  UMAP1 = l_umap_result$layout[, 1],
  UMAP2 = l_umap_result$layout[, 2],
  cluster = d_left$cluster,
  inducedVB = d_left$ivb,
  VB = d_left$vb,
  HB = d_left$hb,
  # velocity = d_left$velocity,
  # spin_rate = d_left$spin_rate,
  # spin_axis = d_left$spin_axis,
  TaggedPitchType = d_left$TaggedPitchType,
  AutoPitchType = d_left$AutoPitchType
)

# lhp interactive plot
plot_lhp <- plot_ly(
  l_umap_df,
  x = ~UMAP1,
  y = ~UMAP2,
  type = 'scatter',
  mode = 'markers',
  color = ~cluster,
  colors = hue_pal()(best_kl),
  text = ~paste(
    "Cluster:", cluster,
    "<br>Tagged:", TaggedPitchType,
    "<br>Auto:", AutoPitchType,
    "<br>Induced VB (deg):", round(inducedVB, 2),
    "<br>VB (deg):", round(VB, 2),
    "<br>HB (deg):", round(HB, 2)
    # "<br>Velocity (m.s):", round(velocity, 1),
    # "<br>Spin Rate (deg/s):", round(spin_rate, 0),
    # "<br>Spin Axis (deg):", round(spin_axis, 0)
  ),
  marker = list(size = 8, opacity = 0.8)
) %>%
  layout(
    title = "LHP GMM Clustering (UMAP Projection)",
    xaxis = list(title = "UMAP1"),
    yaxis = list(title = "UMAP2"),
    legend = list(title = list(text = "Cluster"))
  )
```

View Cluster plots
```{r UMAP plots}
print(plot_rhp)
print(plot_lhp)

htmlwidgets::saveWidget(
  widget = plot_rhp,
  file = "UMAP for RHP Break Profile.html",
  selfcontained = TRUE
)

htmlwidgets::saveWidget(
  widget = plot_lhp,
  file = "UMAP for LHP Break Profile.html",
  selfcontained = TRUE
)

# UMAP isn't particularly helpful in terms of interpreting the data (clusters differences).So, we'll need a different approach.
```


```{r UMAP with facet wrapping}
UMAP_rhp <- ggplot(r_umap_df, aes(x = UMAP1, y = UMAP2, color = cluster)) +
  geom_point(alpha = 0.7, size = 2) +
  facet_wrap(~cluster) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5)) +
  labs(title = "UMAP Faceted by Cluster (RHP)")

UMAP_lhp <- ggplot(l_umap_df, aes(x = UMAP1, y = UMAP2, color = cluster)) +
  geom_point(alpha = 0.7, size = 2) +
  facet_wrap(~cluster) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5)) +
  labs(title = "UMAP Faceted by Cluster (LHP)")

ggsave(UMAP_rhp, file = "UMAP Faceted by Cluster - RHP.png", dpi = 600)
ggsave(UMAP_lhp, file = "UMAP Faceted by Cluster - LHP.png", dpi = 600)

# these plots allow us to separate the UMAP into the individual clusters
```

Summarise each cluster with quartiles and IQRs
```{r IQR summary}
# RHP
cluster_summary_rhp <- d_right %>%
  group_by(cluster) %>%
  summarise(across(all_of(features), list(
    Q1 = ~quantile(.x, 0.25, na.rm = TRUE),
    Q3 = ~quantile(.x, 0.75, na.rm = TRUE),
    median = ~median(.x, na.rm = TRUE),
    IQR = ~IQR(.x, na.rm = TRUE)
  ), .names = "{.col}_{.fn}")) %>%
  ungroup()

# save the summary data for RHP
write.csv(cluster_summary_rhp, file = "Data/RHP Cluster Summary.csv", row.names = FALSE)

# LHP
cluster_summary_lhp <- d_left %>%
  group_by(cluster) %>%
  summarise(across(all_of(features), list(
    Q1 = ~quantile(.x, 0.25, na.rm = TRUE),
    Q3 = ~quantile(.x, 0.75, na.rm = TRUE),
    median = ~median(.x, na.rm = TRUE),
    IQR = ~IQR(.x, na.rm = TRUE)
  ), .names = "{.col}_{.fn}")) %>%
  ungroup()

# save the summary data for LHP
write.csv(cluster_summary_lhp, file = "Data/LHP Cluster Summary.csv", row.names = FALSE)
```


```{r pitches included in each cluster}
pitchtype_summary_rhp_auto <- d_right %>%
  group_by(cluster, AutoPitchType) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(cluster) %>%
  mutate(percent = round(n / sum(n) * 100, 1)) %>%
  arrange(cluster, desc(n))

# save the auto tagged cluster summary data for RHP
write.csv(pitchtype_summary_rhp_auto, file = "Data/RHP Auto Tagged Cluster Summary.csv", row.names = FALSE)

pitchtype_summary_rhp_tagged <- d_right %>%
  group_by(cluster, TaggedPitchType) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(cluster) %>%
  mutate(percent = round(n / sum(n) * 100, 1)) %>%
  arrange(cluster, desc(n))

# save the tagged cluster summary data for RHP
write.csv(pitchtype_summary_rhp_tagged, file = "Data/RHP Tagged Cluster Summary.csv", row.names = FALSE)

pitchtype_summary_lhp_auto <- d_left %>%
  group_by(cluster, AutoPitchType) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(cluster) %>%
  mutate(percent = round(n / sum(n) * 100, 1)) %>%
  arrange(cluster, desc(n))

# save the auto tagged cluster summary data for RHP
write.csv(pitchtype_summary_lhp_auto, file = "Data/LHP Auto Tagged Cluster Summary.csv", row.names = FALSE)

pitchtype_summary_lhp_tagged <- d_left %>%
  group_by(cluster, TaggedPitchType) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(cluster) %>%
  mutate(percent = round(n / sum(n) * 100, 1)) %>%
  arrange(cluster, desc(n))

# save the tagged cluster summary data for RHP
write.csv(pitchtype_summary_lhp_tagged, file = "Data/LHP Tagged Cluster Summary.csv", row.names = FALSE)
```

Visualise each cluster's ball metrics for LHP
```{r cluster box plots + facet_wrap()}
cluster_r <- d_right %>%
  select(-TaggedPitchType, -AutoPitchType) %>%
  pivot_longer(cols = -cluster,
               names_to = "variable",
               values_to = "value")

ggplot(cluster_r, aes(x = variable, y = value, fill = cluster)) +
  geom_boxplot(outlier.shape =  NA) +
  facet_wrap(~variable, scales = "free") +
  labs(title = "RHP") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

cluster_l <- d_left %>%
  select(-TaggedPitchType, -AutoPitchType) %>%
  pivot_longer(cols = -cluster,
               names_to = "variable",
               values_to = "value")

ggplot(cluster_l, aes(x = variable, y = value, fill = cluster)) +
  geom_boxplot(outlier.shape =  NA) +
  facet_wrap(~variable, scales = "free") +
  labs(title = "LHP") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# these plots are a little conjested, so we'll use facet_wrap() to panel them into single variables
```

```{r cluster box plots with purrr}
install.packages("purrr")
library(purrr)

# split data by variable
plots_r <- cluster_r %>%
  split(.$variable) %>%
  map(~ ggplot(.x, aes(x = cluster, y = value, fill = cluster)) +
        geom_boxplot(outlier.shape = NA) +
        geom_jitter(aes(fill = cluster),
                    shape = 21,      
                    position = position_jitter(width = 0.25),
                    alpha = 0.3,
                    size = 1.5,
                    colour = "black") +
        theme_classic() +
        labs(x = "Pitch Cluster",
             y = NULL,
             title = paste0("RHP - ", unique(.x$variable))) +
        theme(plot.title = element_text(hjust = 0.5),
              legend.position = "none")
      )

# split data by variable
plots_l <- cluster_l %>%
  split(.$variable) %>%
  map(~ ggplot(.x, aes(x = cluster, y = value, fill = cluster)) +
        geom_boxplot(outlier.shape = NA) +
        geom_jitter(aes(fill = cluster),
                    shape = 21,      
                    position = position_jitter(width = 0.25),
                    alpha = 0.3,
                    size = 1.5,
                    colour = "black") +
        theme_classic() +
        labs(x = "Pitch Cluster",
             y = NULL,
             title = paste0("LHP - ", unique(.x$variable))) +
        theme(plot.title = element_text(hjust = 0.5),
              legend.position = "none")
      )

# loop through to print all
walk(plots_r, print)
walk(plots_l, print)

# save each plot with a unique file name
walk2(.x = plots_r,
      .y = names(plots_r),
      .f = ~ ggsave(filename = paste0("RHP - ", .y, ".png"),
                    plot = .x,
                    width = 7, height = 5, dpi = 600)
      )

walk2(.x = plots_l,
      .y = names(plots_l),
      .f = ~ ggsave(filename = paste0("LHP - ", .y, ".png"),
                    plot = .x,
                    width = 7, height = 5, dpi = 600)
      )

# these plots make it much easier to interpret since the y values are specific to each variable
```


```{r GGally - line plot, eval=FALSE}
install.packages("GGally")
library(GGally)

GGally::ggparcoord(
  data = d_right,
  columns = which(names(d_right) %in% features),
  groupColumn = "cluster",
  scale = "uniminmax",
  alphaLines = 0.3
) +
  theme_minimal() +
  facet_wrap(~cluster)
  labs(title = "Cluster Profiles (RHP)", x = "Feature", y = "Normalized Value")

# these plots are difficult to interpret as they are. Unfortunately, GGally doesn't support facet_wrap() by variable!
```

Now we just need to play around with HDBSCAN/DBSCAN

```{r DBSCAN analysis}
rX_break <- scale(d_right[, features2])
lX_break <- scale(d_left[, features2])

# run HDBSCAN with a sensible minPts (e.g., 20)
hdb_r <- hdbscan(rX_break, minPts = 20)

# add clusters back to original df
d_right$hdb_cluster <- as.factor(hdb_r$cluster)
cat("Unique clusters for RHP:", length(unique(hdb_r$cluster[hdb_r$cluster > 0])), "\n")

# run HDBSCAN with a sensible minPts (e.g., 20)
hdb_l <- hdbscan(lX_break, minPts = 20)

# add clusters back to original df
d_left$hdb_cluster <- as.factor(hdb_l$cluster)
cat("Unique clusters for LHP:", length(unique(hdb_l$cluster[hdb_l$cluster > 0])), "\n")
```

```{r visualise DBSCAN models with UMAP}
set.seed(0312)

# right
r_umap_break <- umap(rX_break)

r_umap_df_break <- data.frame(
  UMAP1 = r_umap_break$layout[, 1],
  UMAP2 = r_umap_break$layout[, 2],
  cluster = d_right$hdb_cluster,
  vb = d_right$vb,
  hb = d_right$hb,
  ivb = d_right$ivb,
  TaggedPitchType = d_right$TaggedPitchType,
  AutoPitchType = d_right$AutoPitchType
)

plot_hdb_rhp <- plot_ly(
  r_umap_df_break,
  x = ~UMAP1,
  y = ~UMAP2,
  type = 'scatter',
  mode = 'markers',
  color = ~cluster,
  text = ~paste(
    "Cluster:", cluster,
    "<br>Tagged:", TaggedPitchType,
    "<br>Auto:", AutoPitchType,
    "<br>VB:", round(vb, 1),
    "<br>HB:", round(hb, 1),
    "<br>IVB:", round(ivb, 1)
  ),
  marker = list(size = 8, opacity = 0.8)
) %>%
  layout(
    title = "RHP HDBSCAN Clustering (UMAP Projection)",
    xaxis = list(title = "UMAP1"),
    yaxis = list(title = "UMAP2"),
    legend = list(title = list(text = "Cluster"))
  )

print(plot_hdb_rhp)

# left
l_umap_break <- umap(lX_break)

l_umap_df_break <- data.frame(
  UMAP1 = l_umap_break$layout[, 1],
  UMAP2 = l_umap_break$layout[, 2],
  cluster = d_left$hdb_cluster,
  vb = d_left$vb,
  hb = d_left$hb,
  ivb = d_left$ivb,
  TaggedPitchType = d_left$TaggedPitchType,
  AutoPitchType = d_left$AutoPitchType
)

plot_hdb_lhp <- plot_ly(
  l_umap_df_break,
  x = ~UMAP1,
  y = ~UMAP2,
  type = 'scatter',
  mode = 'markers',
  color = ~cluster,
  text = ~paste(
    "Cluster:", cluster,
    "<br>Tagged:", TaggedPitchType,
    "<br>Auto:", AutoPitchType,
    "<br>VB:", round(vb, 1),
    "<br>HB:", round(hb, 1),
    "<br>IVB:", round(ivb, 1)
  ),
  marker = list(size = 8, opacity = 0.8)
) %>%
  layout(
    title = "LHP HDBSCAN Clustering (UMAP Projection)",
    xaxis = list(title = "UMAP1"),
    yaxis = list(title = "UMAP2"),
    legend = list(title = list(text = "Cluster"))
  )

print(plot_hdb_lhp)

htmlwidgets::saveWidget(
  widget = plot_hdb_rhp,
  file = "UMAP for RHP Break Profile (DBSCAN).html",
  selfcontained = TRUE
)

htmlwidgets::saveWidget(
  widget = plot_hdb_lhp,
  file = "UMAP for LHP Break Profile (DBSCAN).html",
  selfcontained = TRUE
)

```


```{r summary data - DBSCAN}

summary_stats_rhp <- d_right %>%
  filter(hdb_cluster != 0) %>%  # exclude noise
  group_by(hdb_cluster) %>%
  summarise(across(all_of(features2), list(
    median = ~median(., na.rm = TRUE),
    Q1 = ~quantile(., 0.25, na.rm = TRUE),
    Q3 = ~quantile(., 0.75, na.rm = TRUE),
    IQR = ~IQR(., na.rm = TRUE)
  ), .names = "{.col}_{.fn}")) %>%
  ungroup()

freq_summary_rhp_tagged <- d_right %>%
  filter(hdb_cluster != 0) %>%
  group_by(hdb_cluster, TaggedPitchType) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(hdb_cluster) %>%
  mutate(percent = round(n / sum(n) * 100, 1)) %>%
  arrange(hdb_cluster, desc(n))

freq_summary_rhp_auto <- d_right %>%
  filter(hdb_cluster != 0) %>%
  group_by(hdb_cluster, AutoPitchType) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(hdb_cluster) %>%
  mutate(percent = round(n / sum(n) * 100, 1)) %>%
  arrange(hdb_cluster, desc(n))

# save the summary data for RHP
write.csv(summary_stats_rhp, file = "Data/RHP Cluster Summary (DBSCAN).csv", row.names = FALSE)

# save the tagged cluster summary data for RHP
write.csv(freq_summary_rhp_tagged, file = "Data/RHP Tagged Cluster Summary (DBSCAN).csv", row.names = FALSE)

# save the auto cluster summary data for RHP
write.csv(freq_summary_rhp_auto, file = "Data/RHP Auto Cluster Summary (DBSCAN).csv", row.names = FALSE)


summary_stats_lhp <- d_left %>%
  filter(hdb_cluster != 0) %>%  # exclude noise
  group_by(hdb_cluster) %>%
  summarise(across(all_of(features2), list(
    median = ~median(., na.rm = TRUE),
    Q1 = ~quantile(., 0.25, na.rm = TRUE),
    Q3 = ~quantile(., 0.75, na.rm = TRUE),
    IQR = ~IQR(., na.rm = TRUE)
  ), .names = "{.col}_{.fn}")) %>%
  ungroup()

freq_summary_lhp_tagged <- d_left %>%
  filter(hdb_cluster != 0) %>%
  group_by(hdb_cluster, TaggedPitchType) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(hdb_cluster) %>%
  mutate(percent = round(n / sum(n) * 100, 1)) %>%
  arrange(hdb_cluster, desc(n))

freq_summary_lhp_auto <- d_left %>%
  filter(hdb_cluster != 0) %>%
  group_by(hdb_cluster, AutoPitchType) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(hdb_cluster) %>%
  mutate(percent = round(n / sum(n) * 100, 1)) %>%
  arrange(hdb_cluster, desc(n))

# save the summary data for LHP
write.csv(summary_stats_lhp, file = "Data/LHP Cluster Summary (DBSCAN).csv", row.names = FALSE)

# save the tagged cluster summary data for LHP
write.csv(freq_summary_lhp_tagged, file = "Data/LHP Tagged Cluster Summary (DBSCAN).csv", row.names = FALSE)

# save the auto cluster summary data for LHP
write.csv(freq_summary_lhp_auto, file = "Data/LHP Auto Cluster Summary (DBSCAN).csv", row.names = FALSE)

```

